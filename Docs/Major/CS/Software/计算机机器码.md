# 计算机机器码

## 常见机器码

* 原码

十进制转换成二进制之后的数值，加上**0正1负**的符号位

* 反码

正数的反码是原码本身，负数的反码是**数值位**按位非

* 补码

正数的补码是原码本身，负数的补码是反码+1

* 移码

将符号位取反的补码（不区分正负）


## 数值的机器码值

### 机器码的设计

（此处不讨论移码）
假定现有一个单次最高可处理4位二进制的系统，若只处理正数，那其能处理的数值范围0-15。
现有负数需求，将最高位设定为符号位，设定符号位后，能够存储的正数数值范围要砍对半。
故而需要在十进制转换的二进制数基础之上，进一步设计完善，来储存正数与负数。
根据基础习惯，现在规定原有前半部分的正数数值保持不变，
后半部分的数值来存储负数部分，负数的存储有多种方案，也就是原码、反码、补码。

各数值对应机器码值如下：

![计算机机器码20230223171340](https://raw.githubusercontent.com/skylinety/blog-pics/master/imgs/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%9C%BA%E5%99%A8%E7%A0%8120230223171340.png)

由图可知，正数的原码，反码，补码都全部相同，都是数值对应的实际的二进制。

### 计算机数值储值方式

先说结论：
补码是最优的储存方式，计算机中所有数都是以补码形式存储的。

当计算机进行数值计算时，首先要将十进制转换为机器码。
回到上图的轮盘，
假定当前位置在原点0处为起点，要跑到11的位置，可以前进11步，也可以后退5步。
即
```jsx
+11 == -5
```
满足条件的只有补码。
上面的一个轮盘就是一个模为16的计量系统，不同位数的二进制系统的模为$2^n$。
按照补码的设计，计算机在实际计算负数时就非常方便，
如上要获取-5的补码，直接求11的补码，即直接获取11的二进制。
有比如，在8位二进制计量系统中，求-5的补码，即求$256 - 5 = 251$的二进制，即为11111011。

对应到真实系统，直接用计量系统的模与负数相加即可。

在现实生活中，时钟就是一个以12位模的计量系统。

### 模与同余定理