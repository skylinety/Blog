# 计算机常见术语

<!-- @import "[TOC]" {cmd="toc" depthFrom=1 depthTo=6 orderedList=false} -->

<!-- code_chunk_output -->

- [计算机常见术语](#计算机常见术语)
  - [Web领域](#web领域)
    - [前端工程化](#前端工程化)
    - [大前端](#大前端)
    - [微前端](#微前端)
  - [软件工程领域](#软件工程领域)
    - [鸭子类型](#鸭子类型)
    - [函数重载](#函数重载)
    - [函数签名](#函数签名)
  - [网络安全领域](#网络安全领域)
    - [沙盒（沙箱）](#沙盒沙箱)
  - [BMW WARNING](#bmw-warning)

<!-- /code_chunk_output -->

## Web领域

### 前端工程化


在前后端未分离时代，前端能做的工作很少，
开发基本的展示页面，另外涉及少量的页面交互逻辑，
相比后端，只能算整个大的项目工程中的一小部分。
随着现代应用的复杂化，前端需要承担的职责和开发工作越来越多，前后端开始分离。

前端工程化是将软件工程中的原理与思路用在前端开发上使前端被单独视作一个工程，
从而让前端软件易于迭代，便于维护，高效开发，质量可靠。

前端工程化的前提是前后端分离。
在现代前端中，需要做到：

```jsx
基本展示页面开发

页面完整交互逻辑与页面特效

基础项目构建（gulp、webpack、rollup）

JS预编译(TS、JSX、TSX)

CSS预编译（SCSS、Less）

代码体积压缩(uglyJS)

前端请求代理，接口数据模拟(Mock)

代码模块化开发(RequireJS、ES6)

代码打包部署(webpack、vue-cli)

前端项目版本迭代

前端性能监控

...
```
前端需要承担日益增加的职责，也就一步步向工程化演进。
这些开发过程职责合起来就是一个较大的工程。
这些前端职责随着发展不断演变引入的，后续也会有不同的新职责随着演变不断更新。

### 大前端

随着前端不断地完善与发展，前端工程师能承担的开发工程向多端发展。
越来越多的前端工程师通过Node.js、React Native、Weex、Electron、Flutter、小程序等开发非Web端应用。
浏览器作为前端的本职工作地，最初由Node.js打破，向着不拘泥于Web端应用的大前端方向发展。

### 微前端

为了应对愈来愈庞大的巨石应用以及跨团队协助和使用不同技术栈的问题，
前端工程引入了后端微服务思想理念，微前端诞生。
微前端延续微服务的思路，将庞大的前端项目根据相对独立的功能模块拆解成多个提供不同服务的微项目，
这些项目可分别交于擅长不同领域的团队采用不同技术栈开发，
开发过程，维护迭代过程互不影响。

微前端各子项目一般有如下特性：

技术无关
独立运行
独立维护

早期的微前端使用iframe来实现，当存在重新渲染白屏等可感知的影响用户体验问题。
现在微前端框架不断发展，已有single-spa、qiankun、micro-app等可选择。

微前端框架需要解决如下问题：

路由系统同步
应用集成方式（App Entry）
应用隔离

## 软件工程领域
### 鸭子类型

当看到一只鸟包含当前关注的所有鸭子的特征，即走起来像鸭子、游泳起来像鸭子、叫起来也像鸭子，那么这只鸟就可以被称为鸭子类型。
以TypeScript类型系统为例：
TypeScript 选择了一种基于属性的类型系统（Structural type system）。
这种类型系统不再关注一个变量被标称的类型（由哪一个构造器构造），而是 在进行类型检查时，将对象拆开，逐个去比较组成这个对象的每一个属性或方法。
如果一个对象有着一个类型所要求的所有属性或方法，那么类型检查通过，实际编程时就可以当作这个类型来使用。
### 函数重载

编程语言支持多个同名函数的定义，只是参数的个数或者类型不同。
在调用的时候，解释器会根据参数的个数或者类型，调用对应的函数。

函数重载主要解决实际开发过程中参数类型可变或参数个数可变的问题

函数重载遵循基本的设计原则：
仅仅当两个函数除了参数类型和参数个数不同以外，其功能是完全相同的，此时才使用函数重载。
如果两个函数的功能其实不同，那么不应当使用重载，而应当使用一个名字不同的函数。

函数重载这个特性在很多语言中都有实现，如C++、Java 等。
但 Python JS 并不支持

```py3
def hello(nums2):
    print(nums2)

def hello(nums1, nums2):
    print(nums1, nums2)

hello(1) // TypeError
hello(1,2)
```

上述代码后面的hello会覆盖前一个

执行会抛出异常`Exception has occurred: TypeError hello() missing 1 required positional argument: 'nums2'`

不支持函数重载的语言，原因类似，以Python为例。
Python不支持原因如下：

- 类型可变，功能相同
    
Python 函数可以接受任何类型的参数，功能相同则不需要解决这个问题
    
- 个数可变，功能相同
    
Python提供缺省参数，函数功能相同，内部始终需要对缺少的参数处理
    


### 函数签名

函数（方法）签名主要由具体的输入输出来定义，可以是以下：

- 输入参数与类型
- 输出值与类型
- 可能抛出或传回的异常
- 函数的访问性（面向对象编程中的public, static, prototype）

在可以重载函数的语言中，需要参数类型与个数有差异，通常说要求函数签名不同。


## 网络安全领域
### 沙盒（沙箱）

沙盒（英语：sandbox，又译为沙箱）是一种安全机制，为执行中的程式提供的隔离环境。通常是作为一些来源不可信、具破坏力或无法判定程序意图的程序提供实验之用。
主要用途有测试带病毒程序，测试恶意代码等。
​
## BMW WARNING

- Bulletin

本文首发于 [skyline.show](http://www.skyline.show) 欢迎访问。
文章实时更新，如果有什么错误或不严谨之处望请指出，十分感谢。
如果你觉得有用，欢迎到[Github仓库](https://github.com/skylinety/Blog)点亮⭐️


> I am a bucolic migant worker but I never walk backwards.

- Material

参考资料如下列出，部分引用可能遗漏或不可考，侵删。

>  https://zh.wikipedia.org/zh-hans/%E6%B2%99%E7%9B%92_(%E9%9B%BB%E8%85%A6%E5%AE%89%E5%85%A8)​

- Warrant

本文作者： Skyline(lty)

文章链接：[http://www.skyline.show/计算机常见术语.html](http://www.skyline.show/计算机常见术语.html)

授权声明： 本博客所有文章除特别声明外， 均采用 [CC BY - NC - SA 3.0](https://creativecommons.org/licenses/by-nc-sa/3.0/deed.zh) 协议。 转载请注明出处！
